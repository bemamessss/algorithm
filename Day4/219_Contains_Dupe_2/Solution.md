# ğŸ“š Coding Test Study - Day 4 (Supplement)

ğŸ“‹Â **ì˜¤ëŠ˜ì˜ ë¬¸ì œ:**Â LeetCode #219. Contains Duplicate II

## 1. ë¬¸ì œ í•µì‹¬ ìš”ì•½

- **ëª©í‘œ:**Â ë°°ì—´Â `nums`ì—ì„œÂ `nums[i] == nums[j]`ì´ê³ , ë‘ ì¸ë±ìŠ¤ì˜ ê±°ë¦¬ ì°¨ì´Â `abs(i - j) <= k`ë¥¼ ë§Œì¡±í•˜ëŠ” ìŒì´ ìˆëŠ”ì§€ í™•ì¸.
- **ì¡°ê±´:** ë°°ì—´ ê¸¸ì´: $10^5$
    - ê±°ë¦¬ ì œí•œ $k$: $10^5$
    - ì¦‰, ë‹¨ìˆœíˆ ëª¨ë“  ìŒì„ ë¹„êµí•˜ëŠ” $O(n^2)$ì€ ë¶ˆê°€ëŠ¥í•˜ë©°, **í•´ì‹œ(Hash)**ë‚˜ **ìŠ¬ë¼ì´ë”© ìœˆë„ìš°**ë¥¼ ì¨ì•¼ í•¨.

---

## 2. ì•Œê³ ë¦¬ì¦˜ í¬ì¸íŠ¸: Sliding Window & Hash

ì´ ë¬¸ì œëŠ” ë‘ ê°€ì§€ ë°©ë²•ìœ¼ë¡œ í’€ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì£¼ì„ì„ í†µí•´Â `i - k`ì™€Â `size > k`ì˜ ì˜ë¯¸ë¥¼ ì™„ë²½íˆ ì´í•´í•´ ë´…ì‹œë‹¤.

### âœ… ë°©ë²• 1: Hash Set + Sliding Window (ì¶”ì²œ)

ìœˆë„ìš°ì˜ í¬ê¸°ë¥¼ ì¼ì •í•˜ê²Œ ìœ ì§€í•˜ë©° "ì´ ì•ˆì— ì¤‘ë³µì´ ìˆëŠ”ê°€?"ë§Œ í™•ì¸í•˜ëŠ” ë°©ì‹ì…ë‹ˆë‹¤.

```java
class Solution {
    public boolean containsNearbyDuplicate(int[] nums, int k) {
        Set<Integer> set = new HashSet<>();

        for (int i = 0; i < nums.length; i++) {
            // 1. ì¤‘ë³µ ë°œê²¬ ì‹œ ì¦‰ì‹œ ë°˜í™˜
            // í˜„ì¬ ìœˆë„ìš°(ìµœëŒ€ í¬ê¸° k) ì•ˆì— ì´ë¯¸ ìˆ«ìê°€ ìˆë‹¤ë©´ ì¡°ê±´ ì¶©ì¡±!
            if (set.contains(nums[i])) return true;

            // 2. í˜„ì¬ ìˆ«ì ì¶”ê°€
            set.add(nums[i]);

            // 3. [í•µì‹¬ ì£¼ì„: size > k ì™€ i - kì˜ ê´€ê³„]
            // setì˜ í¬ê¸°ê°€ kë¥¼ ì´ˆê³¼í–ˆë‹¤ëŠ” ê²ƒì€, í˜„ì¬ ì¡°ì‚¬ ë²”ìœ„ê°€ 'ê±°ë¦¬ k'ë¥¼ ë„˜ì–´ì„°ë‹¤ëŠ” ëœ»ì…ë‹ˆë‹¤.
            // ì˜ˆ: k=2ì¼ ë•Œ, ì¸ë±ìŠ¤ 0, 1, 2ê¹Œì§€ ë‹´ê¸°ë©´ set.size()ëŠ” 3ì´ ë©ë‹ˆë‹¤ (3 > 2).
            // ì´ë•Œ ê°€ì¥ ì˜¤ë˜ëœ ì›ì†Œ(ì¸ë±ìŠ¤ i - k)ë¥¼ ì œê±°í•´ì•¼ ë‹¤ìŒ ë£¨í”„ì—ì„œë„
            // í˜„ì¬ ìˆ«ìì™€ì˜ ê±°ë¦¬ê°€ k ì´í•˜ì¸ ë†ˆë“¤ë§Œ setì— ë‚¨ê²Œ ë©ë‹ˆë‹¤.
            if (set.size() > k) {
                // i - këŠ” ìœˆë„ìš°ì˜ ê°€ì¥ ì™¼ìª½ ë ì¸ë±ìŠ¤ì…ë‹ˆë‹¤.
                // í˜„ì¬ iê°€ 3ì´ê³  kê°€ 2ë¼ë©´, 3-2 = 1ë²ˆ ì¸ë±ìŠ¤ëŠ” ë‚¨ê²¨ë‘ê³  0ë²ˆì„ ì§€ì›Œì•¼ í•˜ë¯€ë¡œ
                // ì •í™•íˆëŠ” 'í˜„ì¬ ì¸ë±ìŠ¤ iì—ì„œ kë§Œí¼ ë–¨ì–´ì§„ ë†ˆ'ì„ ì§€ìš°ëŠ” ë¡œì§ì…ë‹ˆë‹¤.
                set.remove(nums[i - k]);
            }
        }
        return false;
    }
}
```

---

### âœ… ë°©ë²• 2: Hash Map (ì¸ë±ìŠ¤ ê¸°ë¡ ë°©ì‹)

"ì´ ìˆ«ìê°€ ë§ˆì§€ë§‰ìœ¼ë¡œ ì–´ë””ì„œ ë‚˜ì™”ì§€?"ë¥¼ ê¸°ì–µí•´ë‘ê³  í˜„ì¬ ì¸ë±ìŠ¤ì™€ ë¹„êµí•˜ëŠ” ë°©ì‹ì…ë‹ˆë‹¤.

```java
class Solution {
    public boolean containsNearbyDuplicate(int[] nums, int k) {
        // Key: ìˆ«ì, Value: ê·¸ ìˆ«ìê°€ ë§ˆì§€ë§‰ìœ¼ë¡œ ë“±ì¥í•œ ì¸ë±ìŠ¤
        Map<Integer, Integer> map = new HashMap<>();

        for (int i = 0; i < nums.length; i++) {
            // [ìƒì„¸ ì£¼ì„: i - map.get() ë¡œì§]
            if (map.containsKey(nums[i])) {
                // ì´ì „ì— ì´ ìˆ«ìë¥¼ ë³¸ ì ì´ ìˆë‹¤ë©´, 'ì§ì „ ìœ„ì¹˜'ì™€ 'í˜„ì¬ ìœ„ì¹˜(i)'ì˜ ê±°ë¦¬ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.
                // ë§Œì•½ i - (ì˜ˆì „ ìœ„ì¹˜) <= k ë¼ë©´ ë¬¸ì œì˜ ì¡°ê±´ì„ ë§Œì¡±!
                if (i - map.get(nums[i]) <= k) {
                    return true;
                }
            }

            // í˜„ì¬ ìˆ«ìì˜ ìœ„ì¹˜ë¥¼ ìµœì‹ í™” (ê°€ì¥ ê°€ê¹Œìš´ ê±°ë¦¬ì˜ ì¤‘ë³µì„ ì°¾ê¸° ìœ„í•´ í•„ìˆ˜)
            map.put(nums[i], i);
        }
        return false;
    }
}
```

---

## ğŸ”“ ë‚´ ë‹µì•ˆ (ì‚¬ê³  ê³¼ì •)

```java
class Solution {
    public boolean containsNearbyDuplicate(int[] nums, int k) {
        Set<Integer> set = new HashSet<>(nums.length);
        for( int i = 0 ; i < nums.length ; i ++ ) {
            // k+1 í¬ê¸°ë¡œ ë§Œë“¤ì–´ ë†“ê³  ê·¸ ì•ˆì— ì¤‘ë³µì´ ìˆìœ¼ë©´ ì¡°ê±´ ë§Œì¡±.
            if( !set.add(nums[i]) ) {
                return true;
            }
            // ì‚¬ì´ì¦ˆ ì´ˆê³¼í•˜ë©´ ì•ë¶€í„° ì§€ì›Œ ë²„ë¦°ë‹¤. => ë¯¸ë¦¬ ì§€ì›Œì•¼ í•¨!! ì•ì—ì„œ ë°”ë¡œ ë„£ìœ¼ë‹ˆê¹Œ.
            if( set.size() > k ) {
                // ìˆœì„œ ë³´ì¥ì´ ì•ˆ ë˜ë‹ˆ ì¸ë±ìŠ¤ ê°œë…ì´ ì—†ìŒ!! ê°’ì„ ì§€ì •í•´ì„œ ì§€ì›Œì•¼ í•œë‹¤. i-kê°€ ì œì¼ ì•ì¸ ê±¸ ì˜ ì´í•´í•˜ì.
                set.remove( nums[i - k] );
            }
        }
        return false;
    }
}
```

---

## 3. ì˜¤ëŠ˜ì˜ ê¹¨ë‹¬ìŒ (Key Takeaways)

### ğŸ’¡Â `size > k`Â vsÂ `i - k`Â ì™„ë²½ ì •ë¦¬

- **`size > k`** (ì–¸ì œ ì§€ìš¸ê¹Œ?): HashSetì„ ì“¸ ë•Œ, ì£¼ë¨¸ë‹ˆì— ë‹´ê¸´ ë°ì´í„°ê°€ ìš°ë¦¬ê°€ í—ˆìš©í•˜ëŠ” ê±°ë¦¬ $k$ë³´ë‹¤ ë§ì•„ì§€ëŠ” ìˆœê°„ì„ í¬ì°©í•˜ëŠ” íŠ¸ë¦¬ê±°ì…ë‹ˆë‹¤.
- **`i - k`** (ë¬´ì—‡ì„ ì§€ìš¸ê¹Œ?): ìœˆë„ìš°ê°€ ì˜¤ë¥¸ìª½ìœ¼ë¡œ í•œ ì¹¸ ì´ë™í•  ë•Œ, ìœˆë„ìš°ì˜ ìœ íš¨ ë²”ìœ„ë¥¼ ë²—ì–´ë‚˜ ë²„ë¦° **ê°€ì¥ ì™¼ìª½ì˜ ë‚™ì˜¤ì**ì˜ ì¸ë±ìŠ¤ì…ë‹ˆë‹¤.

### ğŸ’¡ ì™œ HashMapë³´ë‹¤ HashSet ìŠ¬ë¼ì´ë”© ìœˆë„ìš°ê°€ ë§¤ë ¥ì ì¸ê°€?

- HashMapì€ ë°°ì—´ì˜ ëª¨ë“  ê³ ìœ  ìˆ«ìë¥¼ ë‹¤ ê¸°ì–µí•´ì•¼ í•  ìˆ˜ë„ ìˆì§€ë§Œ ($O(n)$ ê³µê°„), ìŠ¬ë¼ì´ë”© ìœˆë„ìš° ë°©ì‹ì€ **í•­ìƒ `set.size()`ê°€** $k$**ë¥¼ ë„˜ì§€ ì•Šë„ë¡** ìœ ì§€í•˜ê¸° ë•Œë¬¸ì— ê³µê°„ ë³µì¡ë„ ë©´ì—ì„œ í›¨ì”¬ íš¨ìœ¨ì ì¼ ë•Œê°€ ë§ìŠµë‹ˆë‹¤. (ìµœì•…ì˜ ê²½ìš° $O(\min(n, k))$)

---

## 4. Dry Run (ì‹œë®¬ë ˆì´ì…˜)

> **ì…ë ¥:**Â `nums = [1, 2, 3, 1, 2]`,Â `k = 2`
> 
1. `i=0`:Â `set={1}`
2. `i=1`:Â `set={1, 2}`
3. `i=2`:Â `set={1, 2, 3}`Â ->Â `size(3) > k(2)`Â ì´ë¯€ë¡œÂ `nums[2-2]`ì¸Â `nums[0]=1`Â ì‚­ì œ.Â `set={2, 3}`
4. `i=3`:Â `nums[3]=1`Â í™•ì¸.Â `set`ì— ì—†ìŒ.Â `set={2, 3, 1}`Â ->Â `size(3) > k(2)`Â ì´ë¯€ë¡œÂ `nums[3-2]`ì¸Â `nums[1]=2`Â ì‚­ì œ.Â `set={3, 1}`
5. `i=4`:Â `nums[4]=2`Â í™•ì¸.Â `set`ì— ì—†ìŒ. ... ìµœì¢…Â `false`.

---

**ë‹¤ìŒì— ì œê°€ ë„ì™€ë“œë¦´ê¹Œìš”?**

ì´ ì›ë¦¬ë¥¼ ì´í•´í•˜ì…¨ë‹¤ë©´, í•©(Sum)ì„ ê¸°ì¤€ìœ¼ë¡œ ìœˆë„ìš°ë¥¼ ì¡°ì ˆí•˜ëŠ”Â **#209. Minimum Size Subarray Sum**Â ë¬¸ì œë¥¼ í’€ ì¤€ë¹„ê°€ ë˜ì…¨ìŠµë‹ˆë‹¤! ì•„ë‹ˆë©´ ì•„ê¹Œ ë§ì”€ë“œë¦°Â **#242. Valid Anagram**ìœ¼ë¡œ ë„˜ì–´ê°€ì„œ í•´ì‹œ ê¸°ì´ˆë¥¼ ë” ë‹¤ì ¸ë³¼ê¹Œìš”? ë„ì™€ë“œë¦´ ì¤€ë¹„ê°€ ë˜ì–´ìˆìŠµë‹ˆë‹¤! ğŸ«¡